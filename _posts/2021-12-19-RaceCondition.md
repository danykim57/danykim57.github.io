---
title:  "레이스 컨디션 - 1"
header:
  teaser: "https://farm5.staticflickr.com/4076/4940499208_b79b77fb0a_z.jpg"
categories: 
  - Concurrency
tags:
  - Concurrency
---
  출처: Modern Operating Systems 4th Edition by Andrew Tanenbaum
  
  레이스 컨디션(race condition)은 서로 다른 쓰레드나 프로세스가 공유 자원(메모리와 같은 것)을 서로 가져다가 쓰려고 하는 상황에서 벌어지는
  
 경쟁을 말한다. 단순하게 그냥 레이스 컨디션이 일어나지 않을 것이다라고 생각하면서 프로그램을 짜면 좋겠지만 아쉽게도 컴퓨터 기술은 머피의 법칙이
 
 굉장히 강하게 작용한다. 예로 미국 북동부 지역에 대정전 사태가 일어났는데 그 원인이 전력 관리 프로그램에서 약 몇 천억 분의 1의 확률로 일어나는
 
 버그가 일어났기 때문이다. 매 초 너무나 많은 연산을 하는 컴퓨터에서 레이스 컨디션은 거의 무조건 일어난다.
 
  레이스 컨디션이 일어나는 이유는 공유자원에 접근을 하는 다른 두 개체가 있기 때문인데 이 공유자원을 임계구역(Critical Region)이라고도 표현한다.
  
 가장 간단하게 임계구역에서의 레이스 컨디션이 일어나지 않는 방법은 상호 배제(mutual exclusion)을 하여서 서로가 순차적으로 임계구역에 들어가서 공유자원을 사용하도록 만드는 것 이다.
 
  이 해결책을 4가지로 구성을 할 수 가 있다.
  
 1. 두 개체가 같이 임계구역에 들어가지 않게 한다.
 2. CPU의 숫자나 속도에 대한 고려가 필요없는 가정을 가지도록 한다.
 3. 임계구역 밖의 프로세스가 다른 프로세스를 막지 않도록 한다.
 4. 임계구역 밖에서 기다리는 프로세스가 영원히 임계구역에 들어가지 못하는 일이 벌어지지 않도록 한다.

이 해결책을 위한 접근들은 다음이 있다.

1. 시스템 인터럽트를 꺼버린다.

 임계구역에서 프로세스가 작업을 할 때 시스템 인터럽트를 끄고 프로세스가 나올 때 시스템 인터럽트를 켜버리면

임계구역에 프로세스가 간섭 받을 일이 없다. 그러나 운영체제는 각각의 프로세스들을 관리를 해주어야 하는데

시스템 인터럽트를 꺼버리면 운영체제가 이 프로세스의 통제를 잃어버리기 때문에 좋은 방법이 아니다. 또한 임계구역에

있는 프로세스가 통제가 안되는 상태로 계속 박혀있는 일 또한 일어날 수 있다. 그리고 커널 레벨의

시스템 인터럽트를 키고 끄는 것은 상당히 큰 비용을 초래한다.

예를 들어서 라이엇 게임즈가 발로란트에 뱅가드 시스템을 도입할 때 많은 기술자인 사용자들이 불평한 것이 이 안티 치팅 시스템이 커널레벨에서

너무 많은 리소스를 빨아먹는다는 점이다.

2. 락변수(Lock Variable)를 설정한다
 
 요즘 식당 화장실을 이용할 때 열쇠를 받아서 가야하는 것 처럼 임계구역을 열쇠인 락이 없으면 못들어가게 하는 방법이다.

컴퓨터상에서는 이 열쇠를 서로 가져간 줄 알고 락변수를 둘다 가져가는 경우가 있다. 물리적인 열쇠가 있다면 이런 일이 벌어지지 

않지만 찰나에 연산이 되는 컴퓨터에서는 아이러니하게 열쇠가 동시에 두개가 만들어지는 경우가 생기기에 이 방법도 좋지 않다.

3. 엄격한 대체(Strict Alteration)

 화장실에 이용자가 있는 동안에 다른 사용자가 화장실 밖에서 계속 기다리는 방법도 있다.

문제는 여러 프로세스들이 busy waiting으로 계속 화장실 문을 두들기는 행위를 하고 있다는 점인데

이 행위에서 CPU 자원을 굉장히 많이 낭비를 하면서 프로세스 간의 할당된 자원과 속도가 다르기에

좀 더 빠르게 노크를 두들기는 사용자가 화장실로 들어가고 느리게 노크를 두들기는 사용자는 화장실 밖에서

계속 기다리게 되는 상황이 발생될 수 있다.

4. 피터슨의 해결법(Peterson's solution)

 레이스 컨디션을 락변수와 주의 변수 두가지로 해결하는 방법을 네덜란드의 컴퓨터 과학지인 데커가 거론하였다.

이것을 좀 더 세련되게 피터슨이 해결법을 만들었다. 피터슨은 enter_region과 levae_region을 이용하여서

상호배제를 하는 방식을 만들었다. 문제는 이 해결법도 동시에 두 개체가 enter_region을 요청하고 변수를

바꿀 경우에 위에 2번에서 보였던 같은 현상이 벌어진다.

5. TSL(Test and Set Lock) Instruction

 소프트웨어 개발자들의 동시성 문제를 풀기 위한 방법들을 보고 있던 하드웨어 개발자들이 하드웨어 레벨에서

락을 걸어 버릴 수 있도록 TSL RX Lock을 레지스트리에 넣어버리는 해결책을 만들었다.

이 락에 의해서 메모리 버스(데이터가 돌아다니는 통로) 자체를 막아버려서 다른 프로세스가 작업중에

간섭을 못하도록 상호 배제 시켜버리는 방법이다. 그러나 이 해결법도 상당히 많은 CPU 자원을 사용한다.

6. Sleep and Wake Up

 프로세스들이 자발적으로 임계구역에 들어가기 전에 다른 프로세스가 임계구역에 있는 경우에 잠들어 있다가 
 
임계구역에서 프로세스가 나오면 다시 깨우는 방식이다. 이 해결책은 CPU 자원도 상당히 사용하면서

프로세스의 우선순위에 따라서 우선순위가 낮은 프로세스가 영원히 깨어나지 못하는 사례가 일어날 수 있다.

7. 생산자 소비자 문제(Producer and Consumer problem)

 버퍼를 만들어서 생산자가 임계구역에 들어가야할 프로세스들을 넣어주고 소비자가
 
버퍼에 들어있는 순서대로 프로세스들에게 임계구역에 들어갈 수 있도록 허용해주는 방식이다.

이 방법은 생산자와 소비자가 동시에 일을 하면서 서로 sleep에 들어가면서 작동하지 않는

문제점이 있다.


 지금까지 동시성에서 일어나는 레이스 컨디션의 해결에 대한 접근들을 알아보았다.

다들 동시에 두 개체가 작동을 할 때에서 오는 교착 상태와 CPU 자원을 낭비를 한다는 문제점이 있는데

다음 포스팅에서는 이 두가지를 좀 더 보완한 해결책들에 대해서 알아보도록 하겠다.
[^posts]: Footnote test.
