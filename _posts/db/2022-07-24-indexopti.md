---
title:  "관계형 데이터베이스 최적화"
header:
teaser: "https://farm5.staticflickr.com/4076/4940499208_b79b77fb0a_z.jpg"
categories:
  - db
tags:
  - DB
---

 관계형 데이터베이스의 조회 성능 향상에는 인덱스 테이블이 사용된다.
 
인덱스 테이블(index table): 필요한 테이블 데이터를 빠르게 찾기 위해 테이블의 컬럼을 기준으로 생성되는 테이

인덱스 테이블은 조회 성능은 향상 시키지만 수정 성능은 저하시킨다.

더 적은 컬럼을 가지고 있는 인덱스 테이블로 빠르게 필요한 데이터의 위치를 찾을 수 있지만 

원래 데이터를 가지고 있는 테이블이 수정될 때마다 인덱스 테이블을 재생성하여야 하기 때문이다.


  인덱스 테이블 생성시 주의점

- 복합키의 속성들의 순서에 따라서 성능이 달라진다. 
- 영향을 많이 주는 속성을 가장 앞단으로 써야한다.

인덱스 테이블과 기존의 데이터 테이블은 B Tree나 유사 데이터 구조로 되어있다.

 제약 조건들은 데이터의 무결성을 위해서 쓰이지만 검증을 위한 프로세스가 그대로 성능저하로 돌아온다.

제약 조건은 성능속도와 데이터의 무결성을 고려하여야 한다.


질의언어 이용시의 주의점

- SELECT *을 쓰지 말고 필요한 속성들만 찾도록 한다
- SELECT *을 이용하여야만 할 때는 EXISTS()로 처리가 되는지 시도해본다.
- CROSS JOIN은 지양한다.
- OUTER JOIN들은 순서에 따라서 성능이 달라진다.
- SUB-SELECT는 경우에 따라서 성능 저하를 불러 올 수 있다.
- 문자열의 와일드카드(%)를 앞에 넣어서 데이터 조회량을 늘리지 않도록 주의하여아 한다.
- 필터링에 함수를 넣는 것은 지양하야여한다.


EXPLAIN을 잘 활용하자

질의(Query)의 성능을 측정시킬 수 있는 수단이 EXPLAIN이다.

실행된 쿼리 구절 별로 어떤 형식의 SELECT 절을 이용하였는지: SELECT TYPE(PRIMARY, SUBSELECT, UNION, DERIVED)

테이블의 타입이 기존 테이블의 풀스캔인지 인덱스인지: type (ALL, INDEX)

얼마나 많은 행들을 스캔하였는지: rows

필터링이 어느 정도의 성능을 보였는지: filtered

스캔이 어떻게 이루어졌는지 좀 더 자세한 기타 사항들 또한 보여준다: EXTRA



