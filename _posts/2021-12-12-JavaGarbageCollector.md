---
title:  "자바 메모리 관리"
header:
  teaser: "https://farm5.staticflickr.com/4076/4940499208_b79b77fb0a_z.jpg"
categories: 
  - BackEnd
tags:
  - Java
---
   90년대 초까지 프로젝트 매니저들이 매번 고민을 하던 부분이 소프트웨어 개발에서 메모리 관리 부분을
  
  잘하는 개발자들이 적다는 부분이였다.
  
  실제로 고객이 요구하는 소프트웨어의 기능을 구현하는 것만해도 벅찬 경우가 많기 때문에
  
  C언어에서 메모리 관리를 위해서 매번 free()나 delete를 써주면서 코드를 관리하는 부분이 어렵기 때문이다.
  
  개발환경에서 나오는 다양한 문제들을 해결하기 위해서 Java가 출시되었고
  
  Java의 핵심적인 기능들 중 하나가 메모리관리, Garbage Collector(GC)이다.
  
  
   자바는 버젼마다 메모리관리를 하는 알고리즘이 바뀌는데 이 포스팅에서는 초기에 나온 메모리 관리 알고리즘인
   
  마크 앤드 스위프(Mark-and-Sweep)만 다루어 보도록 한다.
   
  순수 객체 지향언어인 자바에서는 new와 같이 객체 생성을 하는 경우가 많다.
  
  이 객체들을 생성하고 이용하는 작업대라고 볼 수 있는 쓰레드에서는 각각의 객체들의 메모리 주소를 스택이라고 하는
  
  곳에 저장을 하고 그 값을 힙이라고 하는 자바에게 할당된 더 큰 메모리에서 참조하게 되는데
  
  쓰레드들이 객체를 쓰다가 더 이상 안쓰는 객체들이 메모리를 차지하고 있는 경우가 생긴다.
  
  메모리 관리가 익숙하지 않은 개발자 입장에서는 한손으로 원을 그리고 다른 손으로 세모를 계속 그리는 행동을
  
  하는 것과 같이 힘든 일이다.
  
  
   이를 해결하고자 Java 초기에 나온 마크 앤드 스위프트 방식의 GC는 처음에 쓰이고 있는 메모리가 적혀있는
  
  할당 테이블(Allocation table)의 주소들을 전부 안쓰는 상태(dead)로 처리하고 실제로 쓰레드가 이 주소를
  
  쓰는지 확인하면 (live)로 바꾸고 메모리를 쭈욱 보고 나서 마지막에 dead 처리된 주소들의 값을 없애준다.
  
  이렇게 새롭게 쓸 수 있는 메모리가 늘어나게 된다.
  
  
   마크 앤드 스위프트는 자바 앱을 멈추는 Stop-The-World(STW)를 이용해서 이 작업 저 작업 쓰레드가 넘어가는
   
  시간을 없애서 오버헤드가 거의 없다. 또한 한번에 메모리 정리르 하기에 처리 속도가 빠르다.
  
  문제점은 사용자들이 GC가 일어나는 동안에 앱이 멈추어 있고 10ms의 시간도 체감하고 안좋은 사용자 경험을 
  
  줄 수 있기에 마크 앤드 스위프트는 잘 이용되지 않는다. 
  
  또한, 이 GC 버젼에서는 메모리를 하나의 덩어리 처럼 할당을 받아서 이용을 하는데 마크앤드 스위프트를 쓸 때 마다
  
  메모리 중간 중간에 듬성듬성 새로운 빈공간이 생기고 정리가 안되어서 메모리가 조각나는 fragmentation이 일어난다.
  
  이를 해결하기 위해서 GC는 메모리르 한쪽으로 정리 해주는 컴팩티드 알고리즘을 쓰는 쪽으로 바뀌게 된다.
  
  다음 포스팅에서는 Java8 부터 마크 앤드 스위프트 대신 쓰이게된 Garbage First Collector(G1)을 알아보도록 하겠다.

   
출처: 


