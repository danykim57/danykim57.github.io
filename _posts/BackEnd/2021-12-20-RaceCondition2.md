---
title:  "레이스 컨디션 - 2"
header:
  teaser: "https://farm5.staticflickr.com/4076/4940499208_b79b77fb0a_z.jpg"
categories: 
  - Concurrency
tags:
  - Concurrency
---
  출처: Modern Operating Systems 4th Edition by Andrew Tanenbaum
  
  지난 포스팅에서 두 개체가 공유자원을 서로 차지하려고 일어나는 레이스 컨디션의 해결에 대한 접근법들을
  
 알아보았다.
 
  이번 포스팅에서는 실제로 레이스 컨디션을 방지할 수 있는 해결법들을 말해보도록 하겠다.
  
 
 1. 세마포어(Semaphore)

 네덜란드의 컴퓨터 학자 다이직스트라에 의해서 거론되었으며 프로세스가 잠들어있거나 깨어있음을 가르키는

세마포어라고 하는 정수값을 가진 변수를 이용한 방법이다. 세마포어는 깨어있는 프로세스의 수를 뜻한다.

세마포어가 0일때는 모든 프로세스가 잠들어있고 0 이상일 때는 어떤 공유자원에 접근할려는 프로세스가 깨어있는 상태이다.

이 변수값을 바꾸는 함수는 증가함수(up)와 감소함수(down)가 있다.

감소함수는 세마포어의 값이 0이 아니면 값을 낮춘다.

세마포어의 값이 0일 경우에 감소함수는 작동을 하지 않는다.

증가함수는 세마포어의 값을 하나 올린다.

이 두 함수는 항상 더이상 쪼개질 수 없는 단위의 행동에서 작동한다.

이 행동을 원자적 행동(atomic action)이라고 한다.

더이상 쪼개질 수 없는 성질을 원자성(atomicity)이라고 하는데 동기화와 레이스 컨디션을 풀기 위해서는

항상 고려가 되어야하는 필수 요소이다.

이전 포스팅에서 해결 접근법들이 거의 다 가지고 있는 문제점 중 하나가 두 개체가 동시에 공유자원에

접근하는 경우라고 하였다. 이런 상황 자체를 피하기 위해서 두 개체가 작동을 하는 최소 단위의 행위(atomic action)에서

공유자원에 접근하는 순서를 조정해주어야 한다.

증가함수와 감소함수에 원자성을 부여해주는 방법은 단순하게 이 두개의 함수의 구현을 완전히 따로 해주는 것 이다.

이 분리된 구현으로 하나의 함수가 작동하는 동안에 다른 함수가 간섭하지 않게 하여서 원자성을 확보할 수 있다.

이전 포스팅에서 보았던 또다른 문제는 시스템 간섭(System Interrupt)이 너무나도 많은 CPU 자원을 이용한다는 점이다.

하드웨어 레벨에서 이루어지는 접근법인 TSL(Test and Set Lock)도 시스템 간섭으로 많은 CPU자원을 이용하지만

세마포어는 소프트웨어 레벨에서 커널이나 그 밑의 하드웨어 부분까지 가지 않는 해결법이라서 CPU 자원을 많이 사용하지 않는다.

세마포어는 프로세스간의 통신을 통해서 간섭을 막음으로서 약 몇 마이크로초(ms)정도의 자원을 소비하게 된다.

커널레벨에서 지속적으로 시스템 간섭을 일으키는 방식이 아니라서 자원소모가 더 효율적이다.

세마포어의 종류에는 0과 1만을 이용하는 binary semaphores와 동기화(synchronization)이 있다.

 2. 뮤텍스(Mutex)

뮤텍스는 단순화된 세마포어이다. 뮤텍스는 잠금(locked)과 잠금풀림(unlocked) 두가지 상태만을 표시할 수 있고

그러므로 딱 1비트만 사용한다. 물론 실제 구현에서는 0과 1만을 이용하지 않고 더 많은 숫자를 이용하기도 한다.

0은 잠금풀림으로 공유자원을 먼저 도착한 프로세스가 써도 된다는 상태이고 1이상은 잠금이 걸렸다는 것을 뜻한다.

피터슨 해결법의 enter_region 함수처럼 뮤텍스는 공유자원을 이용하는 프로세스가 생기면 숫자를 올린다.

그러나 enter_region 함수와 다른점은 enter_region은 개체가 락을 받지 못하면 받을 때까지 계속 시도를 하지만(busy waiting)

뮤텍스의 경우 쓰레드가 공유자원 접근을 못한 경우에 yield 상태로 바뀌면서 CPU자원을 다른 개체에게 양도해버린다.

 3. 퓨텍스(Futex)

퓨텍스는 Fasuter User space muTEX 의 약자이다. 커널 레벨에서 락을 돌려서 쓰면(spin lock) 너무나 비용이 크기에 유저 환경에서 뮤텍스를

이용하는 방법이다. 리눅스 환경에 적용되어 있는 뮤텍스의 한버젼이다. 

퓨텍스는 두가지로 이루어져 있다: 커널 서비스와 사용자 라이브러리

커널 레벨에서 락을 돌려 쓰는 것은 비용이 너무 많이 들지만 프로세스간에 통신을 하기 위해서는 커널레벨에서 이루어져야한다.

대신 커널 서비스가 하는 일을 최대한 단순화 시켜서 이 통신비용을 줄여준다. 

커널 서비스는 특정 프로세스를 막는 기능밖에 하지 않는다. 즉, 사용자 환경에 있는 프로세스들이 커널 서비스에 의해서 블럭당하지 않는한

자유롭게 공유자원을 이용할 수 있다. 퓨텍스 라이브러리가 실질적으로 락의 사용가능의 유무를 판별하고 커널 서비스에게 해당 프로세스를

대기열에 넣어주라는 요청을 해준다.

퓨텍스 라이브러리가 활동하는 사용자환경에서 락이 사용가능하면 커널서비스는 아무런 일을 할 필요가 없다.

 
 4. 프로세스 쓰레드들에서의 뮤텍스(Mutex in Pthreads)

  메모리에 탑재되어서 실행준비가 된 프로그램을 프로세스라고 한다.
 
 프로세스는 실행하는 기능을 쓰레드라고 하는 녀석을 생성을 하여서 권한을 부여해주는데
 
 각각의 쓰레드들이 공유자원에 접근하는 것을 프로세스가 관리를 해주어야한다.
 
 이때에도 뮤텍스가 이용될 수 있다.
 
 뮤텍스의 작동방식은 앞에서 설명한것과 같지만 차이점이 있는데 상태변수(condition variable)을 추가로 사용한다는 것 이다.
 
 각각의 쓰레드들이 공유자원에 접근을 하고 있는지 접근이 필요한지 접근하여서 작업을 완료했는지에 대한 상태를 상태변수로 표시한다.
 
 주의해야 할점은 상태변수는 메모리를 가지지 않는다. 그래서 기다리고 있지 않는 쓰레드에 상태변수 변경 요청을 날리면
 
 요청이 받아들여지지 않을 수 있다.
 
 
 
 
 다음 장에서는 모니터라고 하는 좀 더 범용적인 해결법에 대해서 알아 보겠다.
   
  
[^posts]: Footnote test.
